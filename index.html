<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>openhab-geojson</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>

  <div id="nav">
  </div>

  <div id="content">
    <svg class="canvas">
      <g class="map"></g>
    </svg>
  </div>

  <script src="http://d3js.org/d3.v6.min.js"></script>
  <script src="common.v6.js"></script>
  <script src="oh/control/OhControl.js"></script>
  <script src="oh/boundary/OhView.js"></script>

  <script>

/**

  d3 js setup

  https://www.d3indepth.com/geographic/

**/

// TODO Mercator could be problematic further up north
let projection = d3.geoMercator()

let geoGenerator = d3.geoPath()
  .pointRadius(40)
  .projection(projection)

function drawArea(geojson) {

  rect = d3.select(".canvas").node().getBoundingClientRect()
  projection.fitExtent([[60,60],[rect.width-60,rect.height-60]], geojson);

  d3.select('#content g.map')
    .selectAll('path').data(geojson.features)
    .enter().append('path')
      .attr('d', geoGenerator)
      .on("click", handleClick)
      .attr('data-type', function(d) {return d.geometry.type})
      .each(function(d) {
        for (var name in d.properties) {
          d3.select(this).attr("data-"+name,d.properties[name])
        }})
}

function drawPoints(points) {
  p = d3.select('#content g.map')
    .selectAll('circle').data(points)
    .enter().append("g")
      .attr("transform", function(d){return "translate("+d.x+","+d.y+")"})
      .on("click", handleClick)

     p.append("circle")
      .attr("r", function(d, i) { return d.r; })
      .attr('data-type', function(d) {return d.geometry.type})
      .each(function(d) {
        for (var name in d.properties) {
          d3.select(this).attr("data-"+name,d.properties[name])
        }})
     p.append("text")
       .attr("text-anchor", "middle")
       .attr("dy", ".35em")
       .attr("class", "label")
       .attr("id", function(d) {return "label-"+d.properties[d.properties['value-type']]})
       .attr("data-label-item", function(d) {return d.properties[d.properties['value-type']]})
}


/**

  ENTRY POINT

**/

var queryString = location.search;
let params = new URLSearchParams(queryString);

let rootgroup = "Home"
let defaultmodes = "Light,DimmableLight"

let group = params.get("group");
group = (group==null)?rootgroup:group;

let modes = params.get("modes");
modes = (modes==null)?defaultmodes:modes;

configurl = "/rest/items/"+rootgroup+"?metadata=geojson&recursive=false"
ohurl = "/rest/items/"+group+"?metadata=geojson&recursive=true"

var enableExport = params.get("export");

d3.json(configurl).then( function(conf) {
  nav = d3.select('#nav')
      .selectAll("a")

  let navgroups = conf.metadata?.geojson?.config?.nav
  if (navgroups) {
    nav.data(navgroups)
      .enter()
          .append("a")
             .attr("class", "btn")
             .attr("href", function(d) { return "?group="+d+"&modes="+modes} )
             .text(function(d) {return d})
  }

  let modgroups = conf.metadata?.geojson?.config?.modes
  if (modgroups) {
    nav.data(modgroups)
      .enter()
          .append("a")
             .attr("class", "btn modes")
             .attr("href", function(d) { return "?group="+group+"&modes="+d} )
             .text(function(d) {return d.substring(0,1)})
  }

    nav.data(["timeline"])
      .enter()
          .append("a")
             .attr("class", "btn")
             .attr("href", function(d) { return "#"} )
             .html('&#x1F550;')
             .on("click", function() {timelapse(this)})

  let rot = conf.metadata?.geojson?.config?.rotation
  if (rot) {
    projection.rotate(rot)
  }
})

d3.json(ohurl).then( function(d) {
  areaGeoJson = area2Geojson(d, [0,0])
  geoJson = points2Geojson(d, [0,0])

  drawArea(areaGeoJson)

  simPoints(geoJson);
  updateOHItems(modes.split(','))

})

function simPoints(pnts) {
    nodes = pnts.features.map(function(n) {
        var pos = projection(n.geometry.coordinates);
        return {
            x: pos[0],
            y: pos[1],
            r: n.properties.r,
            properties: n.properties,
            geometry: n.geometry
        };
    });

  var simulation = d3.forceSimulation(nodes)
    .force('charge', d3.forceManyBody().strength(0.01))
    .force('collision', d3.forceCollide().radius(function(d) {
      return d.r*0.8
    }))
    .stop().tick(3)

   ended(nodes);

  function ended(nodes) {
    drawPoints(nodes);
    updateOHItems(modes.split(','))
  }

}

let lapseInterval = null;
let lapseDate = null;

function timelapse(ele) {
  lapseDate = new Date();
  clearInterval(lapseInterval);
  lapseInterval = setInterval(function(){
    lapseDate = new Date(lapseDate.getTime() - 600000);
    updateOHItems(modes.split(','), lapseDate);
    d3.select(ele).attr('title', lapseDate.toISOString());
  }, 300);
}

  </script>
</body>
</html>
